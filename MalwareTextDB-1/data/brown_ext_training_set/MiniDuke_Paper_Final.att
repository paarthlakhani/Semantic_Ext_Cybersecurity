This piece of malware is made of three components : pdf , main , payload . 
The PDF file embeds exploit code and a dropper that writes the `` main '' DLL component on the drive . 
Additionally , the original PDF also contains a clean PDF file used in the social engineering stage . 
As the malicious PDF file is opened , the Adobe process gets exploited , which results in running the dropper . 
In turn , upon the dropper 's execution , the host process is killed and the clean PDF file gets displayed . 
This trick allows the malware to run inconspicuously , without the user noticing that something has happened in the background . 
The main DLL file is also loaded and runs in installation mode ( see the First Installation section ↓ ) . 
Once installed , the malware calls back home using a URL found via Twitter or Google search query . 
When successfully connected , new updates or payloads are installed under the disguise of .gif 
images . 
There may be other infection mechanisms other than PDF files , but they remain unknown at the moment . 
Until now , we have only found spreading mechanisms that use social engineering via malicious PDF files sent over e-mail ( see Appendix F : Forged documents↓ ) . 
The ( Appendix D : E-Mail samples used in attacks↓ ) section shows such a sample isolated from a real-life attack . 
The following exploits have been used to trigger the infection : 2012 CVE-2011-2462 2013 CVE-2013-0640 The infection vector for the samples dated 2011 is unknown . 
The list of known samples is available in the Samples by Year Appendix ↓ . 
The file contains four or five sections with standard names such as : .text 
, .data 
, .reloc 
, .edata 
, .rdata 
. 
The packer code is relatively small ( < 1024 bytes ) . 
It is encrypted and located in the .text 
section . 
The packer is used to decrypt the main code located in the largest section - usually .data 
or .rdata 
. 
The DLL file only exports one function with a random name . 
Decryption SHA1 : SHA1 ( probably modified ) area1 : a 16-byte zone in the malicious file which holds the query string for Google . 
area2 : a 128-byte zone in the malicious file which holds the encrypted Twitter link . 
This is the case when the malware is started by the dropper . 
The malware awaits for the user to interact with the computer and verifies the input from mouse or keyboard in an endless loop . 
In the first step , the watermark is applied , as described in the Watermark ↓ section . 
After the watermark is applied , the malware re-computes the file 's checksum by using the CheckSumMappedFile ( ) function . 
The file is dropped with a name randomly chosen from a list in the % ALLUSERSPROFILE % \ Application Data folder set to automatically start after reboot as described below :  for samples in 2011/2012 : the malware modifies the Shell key in Software\Microsoft\Windows NT\CurrentVersion\Winlogon . 
The key holds an environment variable which is set to `` rundll32.exe < path_to_dll > , < export_name > '' . 
 for samples collected in 2013 : the malware adds a .lnk 
file to the Startup directory , which would execute the dll using rundll32.exe . 
If there is already a variant of the malware installed before the copy process , the new malware deletes it and creates another combination of names , as well as a new environment variable or .lnk 
file . 
In this stage , the malicious binary checks if the image is rundll32 - and therefore if it is run on the system through the .lnk 
file set in the Startup folder or if it is run from the environment variable . 
Then , a thread is created in which the OpenInputDesktop ( ) function is called in an endless loop with a sleep interval of 5 seconds . 
The malware then waits for user interaction by checking input from the mouse or keyboard . 
The binary also checks the current date , but only uses the current week of the month , the current month and year . 
The sample from 2011 checks for the current date using http : //tycho.usno.navy.mil/cgi- bin/timer.pl The sample from 2012 checks for the current date using http : //www.time- server.org/gettime.php ? country=China The samples compiled in 2013 get the current date from the operating system . 
The malware then removes the watermark , decrypts the data section and attempts to access the Twitter and Google accounts . 
When either of the sites respond , it interprets the received data and decodes the tweets . 
When the tweet is decoded , the malware connects to the command and control server in the message and send information about the infected system . 
The malware then awaits for a response from the command and control center , which comes as an encrypted GIF file . 
Upon decryption , the malware extracts the embedded payload and runs it . 
The payload is often an update . 
After the task has completed , the malware stops . 
Its execution only lasts until it manages to connect to a Twitter account , then it exits , in order to increase its chances of staying undetected . 
However , it still runs for a little while upon every operating system boot . 
The analysis we carried inside the lab reveals that the payloads are not persistent on disk . 
We presume that they are downloaded from a specific location whenever the system boots up . 
When the malware is ran via rundll32.exe upon the first boot , it creates a copy of itself named as tempfile.dat ( in some samples ) and would mark the executable file in order to prevent it from correctly running on other systems . 
This watermarking process involves the modification of two already encrypted data areas at the end of the executable file . 
The first encrypted area is 0x80 bytes large and holds the encrypted Twitter link . 
For samples dated 2011 , this area starts with encrypted ( http : //twitter.com/ < username > ) For samples dated 2012-2013 , the area starts with encrypted ( https : //mobile.twitter.com/ < username > ) The switch to mobile.twitter has been done on purpose in order to keep the data traffic to a minimum when a connection with Twitter is made . 
Also worth mentioning is the fact that the variants we discovered as dated 2012/2013 are connecting via HTTPS . 
The second area is 0x10 bytes long and holds an encrypted string that is used to perform a Google query for samples from 2012/2013 . 
Depending on the string and the current date , a second Twitter handle is generated . 
The sample dated 2011 does not feature this Google search mechanism . 
The data areas do n't start at a specific offset . 
In order to find them , the malware iterates them from their end and looks for the first byte that is not zero . 
This would be the last byte from the small area ( which is 0x10 bytes large ) . 
From here on , it can compute where the larger data area is located in the file . 
After the malware has identified the area offsets , it would start encrypting them . 
A hash is also computed on specific pieces of system information and will be used in the encryption process . 
The malware enumerates every network interface , isolates the first DWORD in the description and writes it to the buffer . 
The result is overwritten to the previously collected data . 
This behavior is probably triggered by a bug . 
The data is padded with zeros in order to achieve a block of 0x40 bytes . 
A SHA-1 hash is then computed on these bytes , which is then used to modify the small data area ( area1 ) . 
For the large data area ( which is 0x80 bytes long ) , the malware does not use the same hash for encryption . 
Instead , it would interchange the first DWORD with the second one in the structure and would re-compute the SHA-1 hash . 
After these operations have completed , a new checksum on the file is computed via the CheckSumMappedFile ( ) function . 
When the malware is run automatically ( through rundll.exe ) , the watermark is removed . 
The malware re-computes the hash based on the information collected from the system and would perform a XOR operation with the keys computed on the data sections as described in the Watermark ↑ section . 
When these operations have completed , the sample loaded in memory would not feature the watermark and the data can be decrypted . 
In order to deter analysis and avoid identification in automated malware research systems , the malware iterates through processes and looks for potentially dangerous processes listed in the Appendix A : Process Blacklist ↓ section . 
If it finds a blacklisted process , the malware modifies the first DWORD in the structure to be hashed in order to ensure that the data can not be correctly decrypted . 
As we discussed in the previous paragraphs , we know that the full Twitter link used by this specific sample is located in the second data section . 
Upon decryption , the buffer should start with http ( s ) : // ( mobile|m ) twitter.com which means that we could find out the encryption key used for watermarking , as the encryption algorithm is a constant , just like the encrypted data . 
We can find all the 16 bytes , since the plain-text is over 16 bytes long . 
As soon as we had the key , we could completely decrypt the full link , including the Twitter username . 
For the first data section - where the Google hyperlink is stored - cryptanalysis can not be performed as we do n't have a prefix of the encrypted text . 
More than that , the length of the encrypted data is exactly the same as the length of the key . 
The process starts with removing the watermark , as described in the Removing the Watermark ↑ section . 
At this point , we can isolate the data , although it is encrypted . 
We proceed then with decrypting the 16-byte section that holds the Google username . 
The decryption key is obtained by computing the CRC on the unpacked code . 
The code starts at offset 0xC and spans until the beginning of the data section ( which is 0x80 bytes long ) . 
Going further , the large area is decrypted with the following algorithm : The result holds the Twitter link with the username . 
If the primary Twitter username ca n't be accessed or if there is an error while contacting the C & C server mentioned in the first tweet , the malware will attempt the same operation with the secondary Twitter account . 
This secondary account is derived from the Google ID ( which is hardcoded into the sample ) and the current date ( current week ) . 
This means that a different ID should come up every week . 
The malware gets the current date , but only keeps the week of the month , month and year . 
These pieces of data are then concatenated with the decrypted data in the first data section . 
A SHA-1 hash is computed on a buffer that has the following structure : Date|GoogleSearchTerm . 
The hash is then converted to Base64 and isolates the first N bytes of the buffer , which are determined by : Special characters are then stripped from the resulting string . 
Character '+ ' becomes 'a ' , and character '/ ' becomes '9 ' . 
The malware variant dated 2011 connects to twitter.com , while the variants isolated in 2012/2013 use mobile.twitter.com instead . 
Every sample comes hardcoded with a version number in the form of a string . 
Every version uses a different Twitter username . 
These are the Twitter accounts extracted from samples throughout the years : 2011 ObamaApril Etoursinfo 2012 RuthHarper14 CurtinDiana trulrich zokath 2013 KellyPalmer20 EdithAlbert1 FontenotHoward JennieCartagena LorindaRay1 TinaPena10 The tweets are encoded in the following form : uri ! wp07VkkxYt3Ag/bdbNgi3smPJvX7+HLEw5H6/S0RsmHKtA== After decryption , the tweets would become URLs to update servers . 
The buffers are decoded using Base64 , then rotates the output to the right ( ROR ) with a variable number of bytes , and then 0x5A is subtracted . 
The encoding is fairly easy by reversing the algorithm . 
If there are connectivity issues while accessing Twitter or if no tweets holding a uri ! command are found , the malware falls back to an alternate backup mechanism . 
A search query with a series of characters is sent to Google . 
The results are then processed until an `` uri ! '' pattern is found . 
2011 zZkadfDljFE94fFa 2012 DFJ2dskl2394FDLI 9LidWIdf230DFkdL zZkOERmcrD94fFLa 666wifjDfjalQWLK 2013 lUFujJFDiufLKWPR HkyeiIDKiroLaKYr HJUlredIREYUkLLa lUFEfiHKDroLaKYr HJUlOIDIREYUkLLa lUFEfiHKljfLKWPR Although it has been implemented , this mechanism has not been used in the wild . 
A Google search for these sequences did not yield any results . 
Most likely , the mechanism has been implemented either for possible victims who had access to Twitter blocked in the firewall or as a failsafe mechanism , should the Twitter accounts get suspended . 
Also worth mentioning is the fact that the publication of any technical papers about MiniDuke with mentions to the uri ! command and these unique sequences would also activate this mechanism . 
If an infected system is unable to connect to Twitter anymore , it would still be able to call back home , as the Google query would return the C & C address in these technical papers . 
Each Twitter username is associated with as many command and control centers as tweets . 
The tweets are encoded as described in the Decoding the Tweets ↑ section . 
After the C & C address is decoded , the malware concatenates it with index.php or main.htm , default.htm , home.htm etc . 
See the Appendix B : Possible channels used for C & C section ↓ . 
2011 ObamaApril ↔ http : //afgcall.com/demo/index.php etoursinfo ↔ http : //hottraveljobs.com/forum/docs/info.php 2012 RuthHarper14 ↔ http : //arabooks.ch/events/ trulrich ↔ http : //tsoftonline.com/conf/ zokath ↔ http : //www.tsoftonline.com/engine/ 2013 EdithAlbert11 ↔ http : //tsoftonline.com/views/ FontenotHoward ↔ http : //arabooks.ch/lib/ TinaPena10 ↔ http : //arabooks.ch/srch/ LorindaRay1 ↔ http : //artas.org/engine/ In the case of Twitter usernames JennieCartagena and CurtinDiana , there are no details about the C & Cs , as these accounts had been suspended and no information was cached by Google . 
The Twitter accounts and their corresponding messages are listed in the Appendix E : Twitter accounts section↓ , along with their timestamp - the date in which action was taken by the attacking party . 
The language of these tweets is particular for non-native English speakers - indefinite articles are missing , but the definite ones are present . 
This is a feature particular to a small number of relatively popular languages that are spoken in Indonesia or Middle East . 
2011 ObamaApril uri ! wp07VkkxYt3Ag/bdbNgi3smPJvX7+HLEw5H6/S0RsmHKtA== etoursinfo uri ! wp07VkkxYmHJnTtmuxrvY8ST8m6It3LjiYEnZvz4Yl/JezdMPBkw5IiVC1al . 
2012 RuthHarper14 I was appointed to a new job , my ID for CV was wrong uri ! wp07VkkxYt3Md/JOnLhzRL2FJv0N9zJnzRNp trulrich uri ! wp07VkkxYmfNkwN2nBmx4ch/Iu2c+GLeyZEDTKU= zokath uri ! wp07VkkxYujRoyJ23DkwZ8mRGx6M9yLeyY8m/Yw48GS/E2k= 2013 EdithAlbert11 Albert , my cousin . 
He is working hard . 
uri ! wp07VkkxYmfNkwN2nBmx4ch/Iu2c+GJow39HbphL FontenotHoward My native town was ruined by tornado . 
uri ! wp07VkkxYt3Md/JOnLhzRL2FJjY8l2It TinaPena10 alas I met new boy uri ! wp07VkkxYt3Md/JOnLhzRL2FJm7Mt7DEWg== LorindaRay1 The weather is good today . 
Sunny ! uri ! wp07VkkxYt3Mne5uiDkz4Il/Iw48Ge/EWg== The malware performs a GET request to a server with a Base64-encoded string that , if decoded , reads the following : For 2011 samples : crc32 country_code ComputerName/ % USERDOMAIN % OS major , minor , sp_major , prod_type , architecture ( 32/64bit ) antivirus_list proxy_list version ( the version of the malicious sample ) All values are split with `` | '' . 
The entire string is encoded in Base64 . 
For 2012/2013 samples : These samples send additional data , such as the system username . 
Another significant change is the fact that the malware encodes the text using XOR and a key that results from SHA-1 hashing of the Google identifier . 
The resulting buffer is then encoded with Base64 . 
This is a practical example of the GET request : ? a=MjIzMTQyMzkzM3xST3xIT01FL0hPTUV8NXwxfDN8MXwwfC18LXwyLjEy & g=MjIzMTQy M. The variables names in the GET requests are randomly-picked . 
The second variable holds a CRC modulo 13D455h on the encoded string . 
The server responds with a GIF file that holds either a DLL or an EXE file . 
After a request is sent to the C2 , the malware receives a file with a .GIF 
header . 
This is usually a valid image that has appended to it a payload or an update in an encrypted form . 
The malware checks for the 'GIF8 ' magic at the beginning of the file and looks for the 0x3b00 word . 
If the pattern is found , the malware isolates the next four bytes that actually represent the decryption key , followed by the encrypted payload . 
Next , the digital signature is verified and then the payload is decrypted . 
If it is a DLL file , it attempts to load it via LoadLibrary ( ) ; if it is an EXE file , it gets written on disk with one of the following names : winupdt.exe , wcsntfy.exe , netmngr.exe , dumpreport.exe , taskhosts.exe , wupdmngr.exe , winhlp.exe , dllhosts.exe , dxdiagupd.exe , dialers.exe , netschd.exe , connwiz.exe , certupdt.exe , repfault.exe , wuapreport.exe , lanmgr.exe . 
The file is then executed . 
The GIF file is digitally signed with RSA 2048bit . 
The signature is located at the end of the GIF file and uses SHA-1 . 
This mechanism ensures that the updates are `` legit '' and prevents an outsider from pushing a fake update . 
The encryption algorithm for these GIF files is a simple XOR operation with a key that rotates on each step The C & C located at http : //hottraveljobs.com/forum/docs/info.php holds a list that resembles log files . 
There are approximately 60 entries which we believe are information about the targets . 
Since we know the form of the data sent over to Command and Control centers , we might be able to get the format for the logs . 
The format is < CRC > |base64| < size > | < md5 > . 
The CRC is a decimal representation , while the < size > field can represent the size of a payload sent to the respective target . 
The < md5 > - value may be the MD5 hash of the payload . 
Example 25479421 84| 4mBwdmBzEaXtEGJSE10Z4mgVEuNV4mBXECt7 gwtgf7EgGBbaHbAs7B7G7Bt0FnlFk17Z 4hTuk1bZ4Ct EiHEU9wEsIoFLgW7mjh3pjCNLfhEuIHzViHbRJwTrk1cS4G3Z4mFS4GAS4mAt4hTtE1PueGPVeF== |0 |0 24194643 63| EucSE6XtEGASE10Z4mFteGFWE14W4wt7gwt1GVzG7gTrgB4sF Vxegv74 d7 01k1IZ4hTtk1bZ4htbgV7 gcBz5f14 UcBbSj2nWih3vJUA Vdm3ZdhTUdmB Uk1cVdmBT dmcT4GbZ4GBY4mcY4mN= |150948 |c026fbffeed6155b f1 86abedb8681257 If the two fields at the end are really representations for < size > and md5 , then we may have 24 different binary files ( see the Appendix C : Possible MD5 hashes for payloads section ↓ ) . 
No files in the list could be found by their corresponding MD5 . 
Each sample of the malware comes with a version number hardcoded in the binary . 
Different versions are usually linked to a different Twitter account . 
The vast number of versions indicates intense activity , but only a limited number of samples are known . 
The timestamp is isolated from the sample 's PE header and represents the moment in which the executable file has been linked . 
Although it can be usually spoofed , we believe it is real , as we were able to correlate it with the moment we received each of the samples . 
2011 2011/06/20 - 0.1 - ObamaApril 2011/10/13 - 2.12 – etoursinfo For the 2011 timeframe , we have two samples . 
The one linked with the ObamaApril Twitter handle - malware version 0.1 - appears to be the oldest sample . 
The jump to version 2.12 can not be justified , and we believe that there are a number of missing samples , which makes year 2011 one of the most active periods for this family of malware . 
However , one could also speculate that the versions do not follow a strict order . 
2012 2012/05/14 - 6.66 - trulrich 2012/05/21 - 5.21 - trulrich 2012/05/23 - 6.67 - zokath 2012/06/06 - 6.06 - tonyafordy 2012/09/04 - 0.49 - CurtinDiana 2012/12/26 - 3.13 - RuthHarper14 For year 2012 , there are a number of different versions , although we do n't know if they follow a strict order or not . 
For instance , version 3.13 was released in December , while version 5.21 was spotted in May . 
It is possible that the servers hosting the samples to have run out of sync . 
This would explain why lower versions have shown up in December . 
2013 2013/02/12 - 1.05 - TinaPena10 2013/02/20 - 1.10 - LorindaRay1 2013/02/20 - 1.12 - EdithAlbert11 2013/02/20 - 1.13 - FontenotHoward 2013/02/21 - 1.10 - LorindaRay1 2013/02/21 - 1.12 - EdithAlbert11 2013/02/21 - 1.13 - FontenotHoward 2013/02/21 - 1.16 - JennieCartagena 2013/02/26 - 1.20 - KellyPalmer20 The versions released in 2013 follow a much stricter order . 
Every subversion of the malware comes with a separate Twitter handle . 
Quick math shows that there are at least 20 Twitter accounts that have been used in the attacks throughout 2013 ( or at least until February 26th , the date of the discovery ) . 
The first defense mechanism to prevent analysis is the presence of the watermark . 
The binary file wo n't properly run on a different machine , since the data inside the malware would be decrypted improperly . 
Other techniques to prevent data decryption are present inside the binary :  Running software used for reverse engineering : OllyDbg , IDA , Process Monitor etc . 
 Running the binary in virtual machines : VMWare and VirtualBox . 
 Breakpoints added to the code or code alteration ( hardware breakpoints need to be used instead ) . 
The malware also monitors for signs of user interaction , a common technique used for anti- emulation and anti-automated malware analysis . 
Another important aspect for versions in 2012 and 2013 is the fact that the malware does not trigger right after installation , but rather wait for a system restart to execute its main code . 
These are the MD5 hashes for the droppers . 
The date is collected from the PE file header of the backdoor in the droppers : 1e1b0d16a16cf5c7f3a7c053ce78f515 , 2012-03-05 b029378966d2694f8abd51f0d6c7822a , 2012-06-15 53db085a276ebbf5798ba756cac833ea , 2013-02-22 The loader decodes the information in the .data 
section with the UCL algorithm , then passes control to the decrypted code . 
This piece of code holds a small loader stub , followed by an executable file which is the backdoor itself . 
The stub overwrites the memory image of the original executable file with the backdoor so it is never written on disk . 
The malware also creates the following key in the Registry HKCU\Software\Microsoft\ApplicationManager with a value of AppID = < random > ( the value is generated via the GetTickCount ( ) function ) . 
Malware then waits in a loop and performs requests to info.leveldelta.com Example : GET /php/text.php ? i=gigogrzf4J74xQdeBqVi6w360xlP2ksrNpY7dxmj Accept : */* User-Agent : Mozilla/4.0 Host : info.leveldelta.com The base64 value in the request is a 30-byte buffer derived from AppID and GetTickCount ( ) and is always different . 
We believe that it is used as an identifier . 
If it gets a response from the server , the malware performs a series of validations and execute the received commands . 
The responses are sent via POST and contain the identifier from the GET request , followed by the command 's result . 
This is the way the malware exfiltrates documents from the target computers . 
mv - Moves a file . 
Uses MoveFileA api . 
cp - Copies a file . 
Uses CopyFileA api . 
rm - Deletes a file . 
Uses DeleteFileA api . 
pwd - Gets current dir . 
Uses GetCurrentDirectoryA api . 
cd - Sets current dir . 
Uses SetCurrentDirectoryA api . 
rmdir - Removes dir . 
Uses RemoveDirectoryA api . 
mkdir - Creates a dir . 
Uses CreateDirectoryA api . 
pskill - Kills process . 
Uses OpenProcess , TerminateProcess apis . 
exew - Create a process . 
Uses CreateProcessA api . 
conf - Gets some configuration data , creates a string `` id : 0x % 08X\char' host : info.leveldelta.com\ port : % d\ delay : % d\ '' cdt - Change to TEMP dir . 
Uses GetTempPathA , SetCurrentDirectoryA APIs . 
dev - Returns the list of drives in the system with their type ( fixed , removable , etc ) . 
The following strings are used for their types : unk , nrt , rmv , fix , net , cdr , ram , und . 
Uses GetLogicalDriveStringsA , GetDriveTypeA apis . 
time - Gets the number of hours since the system was started : `` uptime % 5d. % 02dh '' . 
Uses GetTickCount api . 
info - Gets info about system . 
String generated like : `` % d % s\n % s\ % s\ '' using GetCurrentProcessId , GetModuleFileNameA , GetComputerNameA , GetUserNameA apis . 
exit - `` exiting ... 
'' dir , ls - List files in current dir . 
Uses FindFirstFile ( `` * '' ) , FindNextFile apis . 
exeu - CreateProcessWithLogonW and reads data from pipe . 
ecec - CreateProcessA and read data from pipe . 
put - Writes file on disk from internal buffer . 
Uses CreateFileA , WriteFile apis . 
get - Reads a file in chunks of 0x400 bytes and computes SHA1 on them . 
ps , pslist - Gets info about processes and their modules . 
Uses EnumProcesses , OpenProcess , EnumProcessModules , GetModuleFileNameExA apis . 
We have identified two servers used in the attack ( sample md5/timestamp/server ) : 1e1b0d16a16cf5c7f3a7c053ce78f515 , 2012-03-05 news.grouptumbler.com/news/feed.php b029378966d2694f8abd51f0d6c7822a , 2012-06-15 info.leveldelta.com/php/text.php 53db085a276ebbf5798ba756cac833ea , 2013-02-22 info.leveldelta.com/php/text.php Whois information on news.grouptumbler.com Registrant Contact : Grouptumbler.COM Tim K. Lappin ( ) Fax : 4573 Froe Street Bluefield , WV 24701 Bluefield , WV 24701 US 4573 Froe Street Bluefield , WV 24701 Bluefield , WV 24701 Whois information on info.leveldelta.com Registrant Contact : Abdul Kasim ( ) Fax : 1442 Sokak No 49 Izmir , IZMIR 35432 TR 1442 Sokak No 49 Izmir , IZMIR 35432 TR 626489f8cafacb1b24fe6ecf0db52f23 - The received.gif file , named 3979106736.gif 6bc34809e44c40b61dd29e0a387ee682 - The variant decrypted from the .gif 
file Observations : clean code , generated by the compiler and no obfuscation . 
The file does not have version information or digital signature . 
The malware checks to see if the host computer connects to the Internet through a proxy server . 
If set , the malware uses the proxy settings . 
Regardless of the connection method , the malware connects to 85.95.236.114:443 using sockets . 
It creates an unique identifier ( DWORD size ) , from the socket handle . 
Everything is encrypted with XOR and a value of an address on the stack . 
It sends the identifier on the opened socket . 
It receives 16 bytes from the socket , and creates a MD5 hash on these . 
The MD5 hash will be used as key for the AES algorithm . 
It receives 16 bytes used for AES encryption as initialization vector . 
It receives 4 bytes , it performs a XOR operation with the identifier and allocates memory as follows : malloc ( val XOR user_id ) It receives a number of size bytes , decrypts them with AES and calls the start of the decrypted buffer . 
The payload can be used to load new modules . 
The received code needs to be completely relocatable as the main piece of malware . 
Using this technique , the attackers may introduce malicious code that will never be saved on disk , but rather executed directly from memory . 
We could also presume that some payloads have been exclusively delivered via this channel and ca n't be recovered for forensic investigation because they never made it on the disk drive . 
Information about 85.95.236.114 Location : Turkey Izmir Inetmar Internet Hizmetleri San . 
Tic . 
Ltd. Sti ASN : AS49467 INETMAR INETMAR Internet Hizmetleri Autonomous System ( izmir ) ( registered Jun 15 , 2009 ) Contact : person : Deniz Tosun org : ORG-IiHS1-RIPE address : 1370 sok . 
NO:42 Yalay Is Merkezi Kat:4/406 address : Montro/Konak/IZMIR Country : TR These are the MD5 checksums of the main components , but not payloads , droppers or PDF files . 
